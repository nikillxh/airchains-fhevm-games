import path from "path";
import fs from "fs";
import { JsonRpcProvider, Wallet, Contract } from "ethers";
import { createInstance } from "../utils/createInstance.js";

function getABI(fileName) {
  try {
    const abiFilePath = path.resolve(process.cwd(), `build/${fileName}.json`);
    const abi = fs.readFileSync(abiFilePath, "utf8");
    return JSON.parse(abi);
  } catch (error) {
    console.error("Error reading ABI file:", error.message);
    process.exit(1);
  }
}

export const intractionMint = async (
  filename,
  networkUrl,
  privateKey1,
  contractAddress,
) => {
  try {
    const abi = getABI(filename);
    const provider = new JsonRpcProvider(networkUrl);
    const wallet = new Wallet(privateKey1, provider);
    const contract = new Contract(contractAddress, abi, wallet);

    const tx = await contract.mint(1000);
    return await tx.hash;
  } catch (error) {
    console.log(error);
  }
};

export const decryptMint = async (
  filename,
  networkUrl,
  privateKey,
  contractAddress,
) => {
  try {
    const abi = getABI(filename);
    const provider = new JsonRpcProvider(networkUrl);
    const wallet = new Wallet(privateKey, provider);
    const contract = new Contract(contractAddress, abi, wallet);

    const encryptedBalance = await contract.balanceOf(wallet.address);
    console.log(encryptedBalance);

    // const bal = await contract.balances(wallet.address)
    // console.log(bal)

    const tx1 = await contract.requestDecryptedBalanceOf(
      "0xB223904f93Cf357eB294549A8690576714C6408d",
    );
    // // console.log(tx1)
    await tx1.wait();

    const tx2 = await contract.decryptedBalanceOf(
      "0xB223904f93Cf357eB294549A8690576714C6408d",
    );
    console.log(tx2);
  } catch (error) {
    console.log(error);
  }
};

export const TokenDetails = async (
  filename,
  networkUrl,
  privateKey,
  contractAddress,
) => {
  try {
    const abi = getABI(filename);
    const provider = new JsonRpcProvider(networkUrl);
    const wallet = new Wallet(privateKey, provider);
    const contract = new Contract(contractAddress, abi, wallet);

    const tx1 = await contract.name();
    console.log(tx1);

    const tx2 = await contract.symbol();
    console.log(tx2);

    const tx3 = await contract.totalSupply();
    console.log(tx3);

    const tx4 = await contract.getOwner();
    console.log(tx4);
  } catch (error) {
    console.log(error);
  }
};

export const intractionTransfer = async (
  filename,
  networkUrl,
  privateKey,
  contractAddress,
) => {
  try {
    const abi = getABI(filename);
    const provider = new JsonRpcProvider(networkUrl);
    const wallet = new Wallet(privateKey, provider);
    const contract = new Contract(contractAddress, abi, wallet);

    const fhevmInstance = await createInstance();

    const input = fhevmInstance.createEncryptedInput(
      contractAddress,
      wallet.address,
    );
    input.add64(1337);
    const inputs = input.encrypt();

    const tx = await contract["transfer(address,bytes32,bytes)"](
      "0x85f0556CB63CfCE1796Ff0B2781202dcC33377Af",
      inputs.handles[0],
      inputs.inputProof,
    );

    const asdf = await tx.wait();

    console.log(asdf);

    return await tx.hash;
  } catch (error) {
    console.log(error);
  }
};

export const reencryptBalance = async (
  filename,
  networkUrl,
  privateKey1,
  contractAddress,
) => {
  try {
    const abi = getABI(filename);
    const provider = new JsonRpcProvider(networkUrl);
    const wallet = new Wallet(privateKey1, provider);
    console.log(wallet);
    const contract = new Contract(contractAddress, abi, wallet);
    const instance = await createInstance();

    const { publicKey, privateKey } = instance.generateKeypair();
    console.log(publicKey, privateKey);
    const eip712 = instance.createEIP712(publicKey, contractAddress);
    const signature = await wallet.signTypedData(
      eip712.domain,
      { Reencrypt: eip712.types.Reencrypt },
      eip712.message,
    );
    const bal = await contract.balanceOf(wallet.address);
    console.log(bal);

    const userBalance = await instance.reencrypt(
      bal, // the encrypted balance
      privateKey, // the private key generated by the dApp
      publicKey, // the public key generated by the dApp
      signature.replace("0x", ""), // the user's signature of the public key
      contractAddress, // The contract address where the ciphertext is
      wallet.address, // The user address where the ciphertext is
    );

    console.log(userBalance);
  } catch (error) {
    console.log(error);
  }
};

export const intractionAprrove = async (
  filename,
  networkUrl,
  privateKey,
  contractAddress,
) => {
  try {
    const abi = getABI(filename);
    const provider = new JsonRpcProvider(networkUrl);
    const wallet = new Wallet(privateKey, provider);
    const contract = new Contract(contractAddress, abi, wallet);

    const fhevmInstance = await createInstance();

    const input = fhevmInstance.createEncryptedInput(
      contractAddress,
      wallet.address,
    );
    input.add64(1337);
    const inputs = input.encrypt();

    const tx = await contract["approve(address,bytes32,bytes)"](
      wallet.address,
      inputs.handles[0],
      inputs.inputProof,
    );

    return await tx.hash;
  } catch (error) {
    console.log(error);
  }
};
